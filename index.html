<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knitting Pattern Counter</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üß∂</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .upload-section {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: border-color 0.3s;
        }

        .upload-section:hover {
            border-color: #007bff;
        }

        .upload-section.dragover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }

        input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: #007bff;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .upload-btn:hover {
            background: #0056b3;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .auto-detect-btn {
            background: #17a2b8;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .auto-detect-btn:hover {
            background: #138496;
        }

        .grid-color-btn {
            background: #6f42c1;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .grid-color-btn:hover {
            background: #5a359a;
        }

        .download-btn {
            background: #fd7e14;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .download-btn:hover {
            background: #e8650e;
        }

        .download-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .grid-overlay {
            position: absolute;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-weight: bold;
            color: #333;
        }

        .control-group input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            width: 80px;
            font-size: 16px;
            -moz-appearance: textfield;
        }

        .control-group input[type="range"] {
            width: 150px;
            margin: 0 10px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: inline-block;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        .control-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .control-group label {
            min-width: 120px;
            font-weight: bold;
        }

        .control-group small {
            color: #6c757d;
            font-size: 0.85em;
            font-style: italic;
            min-width: 140px;
        }

        .controls-section {
            margin: 30px 0 20px 0;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 10px;
            border-left: 4px solid #2196f3;
        }

        .controls-section h3 {
            margin-bottom: 10px;
            color: #1976d2;
            font-size: 1.3em;
        }

        .controls-section p {
            color: #424242;
            margin: 0;
        }

        /* Results Explanation Section */
        .results-explanation {
            margin: 30px 0;
            padding: 25px;
            background: #e8f5e8;
            border-radius: 10px;
            border-left: 4px solid #4caf50;
        }

        .results-explanation h3 {
            margin-bottom: 20px;
            color: #2e7d32;
            font-size: 1.4em;
            text-align: center;
        }

        .explanation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .explanation-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
        }

        .explanation-icon {
            font-size: 2em;
            flex-shrink: 0;
        }

        .explanation-item strong {
            display: block;
            margin-bottom: 5px;
            color: #2e7d32;
            font-size: 1.1em;
        }

        .explanation-item p {
            margin: 0;
            color: #424242;
            font-size: 0.95em;
            line-height: 1.4;
        }

        .control-group input[type="range"] {
            flex: 1;
            min-width: 150px;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #333;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .welcome-section {
                padding: 25px 15px;
                margin-bottom: 20px;
            }

            .welcome-section h2 {
                font-size: 1.4em;
                margin-bottom: 10px;
            }

            .welcome-section > p {
                font-size: 1em;
                margin-bottom: 20px;
            }

            .how-it-works {
                padding: 15px;
            }

            .steps {
                flex-direction: column;
                gap: 10px;
            }

            .step {
                text-align: center;
                flex-direction: column;
                gap: 8px;
            }

            .step-content {
                text-align: center;
            }

            .step-image svg {
                width: 80px;
                height: 53px;
            }

            .step-number {
                width: 32px;
                height: 32px;
                font-size: 1em;
            }

            .upload-section {
                padding: 25px 15px;
                margin-bottom: 20px;
            }

            .controls-section {
                margin: 15px 0 10px 0;
                padding: 15px;
            }

            .controls-section h3 {
                font-size: 1.1em;
                margin-bottom: 8px;
            }

            .control-group {
                margin-bottom: 10px;
                padding: 8px;
            }

            /* Compact checkbox layout */
            .control-group:has(input[type="checkbox"]) {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 5px;
                padding: 6px 8px;
            }

            .control-group:has(input[type="checkbox"]) label {
                min-width: auto;
                margin-bottom: 0;
                flex: 1;
                font-size: 0.9em;
            }

            .control-group:has(input[type="checkbox"]) small {
                display: none; /* Hide explanatory text for checkboxes on mobile */
            }

            /* Slider controls - keep vertical but more compact */
            .control-group:has(input[type="range"]) {
                flex-direction: column;
                align-items: stretch;
                margin-bottom: 8px;
                padding: 6px 8px;
            }

            .control-group:has(input[type="range"]) label {
                min-width: auto;
                margin-bottom: 3px;
                font-size: 0.9em;
            }

            .control-group input[type="range"] {
                width: 100%;
                min-width: auto;
                margin: 0;
            }

            .control-group input[type="range"]::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }

            .control-group input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
            }

            .slider-value {
                align-self: center;
                font-size: 16px;
                margin-top: 3px;
            }

            .control-group:has(input[type="range"]) small {
                min-width: auto;
                text-align: center;
                margin-top: 3px;
                font-size: 0.8em;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .results-explanation {
                margin: 15px 0;
                padding: 15px;
            }

            .results-explanation h3 {
                font-size: 1.2em;
                margin-bottom: 12px;
            }

            .explanation-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .explanation-item {
                flex-direction: row;
                text-align: left;
                padding: 10px;
                gap: 10px;
            }

            .explanation-icon {
                font-size: 1.5em;
            }

            .explanation-item strong {
                font-size: 1em;
                margin-bottom: 3px;
            }

            .explanation-item p {
                font-size: 0.85em;
                line-height: 1.3;
            }

            /* Compact button layout */
            .auto-detect-btn, .grid-color-btn, .download-btn {
                padding: 8px 15px;
                font-size: 0.9em;
                margin-bottom: 8px;
            }
        }

        .process-btn {
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .process-btn:hover {
            background: #1e7e34;
        }

        .process-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .canvas-container {
            text-align: center;
            margin-top: 20px;
        }

        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            max-width: 100%;
            height: auto;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 5px;
            font-family: monospace;
        }

        .info pre {
            overflow-x: auto;
            white-space: pre;
            margin: 0;
            padding: 10px 0;
        }

        @media (max-width: 768px) {
            .info {
                margin: 20px -15px 0 -15px;
                border-radius: 0;
            }

            .info pre {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                font-size: 12px;
                line-height: 1.3;
            }
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .legend h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .color-sample {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #333;
            vertical-align: middle;
        }

        /* Welcome Section Styles */
        .welcome-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }

        .welcome-section h2 {
            margin-bottom: 15px;
            font-size: 2em;
            font-weight: 300;
        }

        .welcome-section > p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.9;
            line-height: 1.6;
        }

        .how-it-works {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .how-it-works h3 {
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .steps {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            min-width: 200px;
            text-align: left;
        }

        .step-number {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            flex-shrink: 0;
        }

        .step-content strong {
            display: block;
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        .step-content p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.95em;
            line-height: 1.4;
        }

        .step-image {
            margin-top: 10px;
            display: flex;
            justify-content: center;
        }

        .step-image svg {
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Enhanced Upload Section */
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .upload-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1.4em;
        }

        .upload-section p {
            margin-bottom: 20px;
            color: #666;
            font-size: 1.1em;
        }

        /* Responsive adjustments for welcome section */
        @media (max-width: 768px) {
            .welcome-section {
                padding: 30px 20px;
            }

            .welcome-section h2 {
                font-size: 1.6em;
            }

            .welcome-section > p {
                font-size: 1.1em;
            }

            .steps {
                flex-direction: column;
            }

            .step {
                text-align: center;
                flex-direction: column;
            }

            .step-content {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß∂ Knitting Pattern Counter</h1>

        <div class="welcome-section">
            <h2>Welcome to your digital knitting assistant!</h2>
            <p>Transform your knitting pattern images into easy-to-follow numbered charts. Perfect for complex colorwork, fair isle patterns, and intricate designs.</p>

            <div class="how-it-works">
                <h3>üìã How it works:</h3>
                <div class="steps">
                    <div class="step">
                        <span class="step-number">1</span>
                        <div class="step-content">
                            <strong>Upload your pattern</strong>
                            <p>Choose any knitting chart image (JPG, PNG, GIF)</p>
                            <div class="step-image">
                                <svg width="120" height="80" viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect width="120" height="80" rx="8" fill="#f8f9fa" stroke="#4a90e2" stroke-width="2" stroke-dasharray="5 3"/>
                                    <!-- Image/document icon -->
                                    <rect x="35" y="20" width="30" height="38" rx="2" fill="#e9ecef" stroke="#6c757d" stroke-width="1"/>
                                    <rect x="35" y="20" width="30" height="10" fill="#4a90e2"/>
                                    <!-- Pattern squares inside document -->
                                    <rect x="40" y="35" width="4" height="4" fill="#fd79a8"/>
                                    <rect x="45" y="35" width="4" height="4" fill="#00b894"/>
                                    <rect x="50" y="35" width="4" height="4" fill="#fd79a8"/>
                                    <rect x="55" y="35" width="4" height="4" fill="#00b894"/>
                                    <rect x="40" y="40" width="4" height="4" fill="#00b894"/>
                                    <rect x="45" y="40" width="4" height="4" fill="#fd79a8"/>
                                    <rect x="50" y="40" width="4" height="4" fill="#00b894"/>
                                    <rect x="55" y="40" width="4" height="4" fill="#fd79a8"/>
                                    <!-- Upload arrow pointing to document -->
                                    <path d="M75 30L85 40L75 50M85 40H70" stroke="#28a745" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <text x="60" y="70" text-anchor="middle" fill="#6c757d" font-size="8" font-family="Arial, sans-serif">Upload knitting pattern</text>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">2</span>
                        <div class="step-content">
                            <strong>Auto-detection</strong>
                            <p>The app automatically detects your pattern grid and colors</p>
                            <div class="step-image">
                                <svg width="120" height="80" viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect width="120" height="80" rx="4" fill="#ffeaa7"/>
                                    <!-- Grid pattern -->
                                    <defs>
                                        <pattern id="grid" width="15" height="15" patternUnits="userSpaceOnUse">
                                            <path d="M 15 0 L 0 0 0 15" fill="none" stroke="#74b9ff" stroke-width="1"/>
                                        </pattern>
                                    </defs>
                                    <rect width="120" height="80" fill="url(#grid)" opacity="0.5"/>
                                    <!-- Color squares -->
                                    <rect x="15" y="15" width="12" height="12" fill="#fd79a8"/>
                                    <rect x="30" y="15" width="12" height="12" fill="#00b894"/>
                                    <rect x="45" y="15" width="12" height="12" fill="#fd79a8"/>
                                    <rect x="15" y="30" width="12" height="12" fill="#00b894"/>
                                    <rect x="30" y="30" width="12" height="12" fill="#fd79a8"/>
                                    <rect x="45" y="30" width="12" height="12" fill="#00b894"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="step">
                        <span class="step-number">3</span>
                        <div class="step-content">
                            <strong>Get numbered chart</strong>
                            <p>Each stitch gets numbered for easy counting and tracking</p>
                            <div class="step-image">
                                <svg width="120" height="80" viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect width="120" height="80" rx="4" fill="#dff6dd"/>
                                    <!-- Grid with numbers showing consecutive counting within same color -->
                                    <rect x="15" y="15" width="15" height="15" fill="#fd79a8" stroke="#333" stroke-width="1"/>
                                    <rect x="30" y="15" width="15" height="15" fill="#fd79a8" stroke="#333" stroke-width="1"/>
                                    <rect x="45" y="15" width="15" height="15" fill="#00b894" stroke="#333" stroke-width="1"/>
                                    <rect x="60" y="15" width="15" height="15" fill="#00b894" stroke="#333" stroke-width="1"/>
                                    <rect x="15" y="30" width="15" height="15" fill="#00b894" stroke="#333" stroke-width="1"/>
                                    <rect x="30" y="30" width="15" height="15" fill="#fd79a8" stroke="#333" stroke-width="1"/>
                                    <rect x="45" y="30" width="15" height="15" fill="#fd79a8" stroke="#333" stroke-width="1"/>
                                    <rect x="60" y="30" width="15" height="15" fill="#fd79a8" stroke="#333" stroke-width="1"/>
                                    <!-- Numbers showing consecutive counting within same colors -->
                                    <text x="22.5" y="25" text-anchor="middle" fill="white" font-size="9" font-weight="bold">1</text>
                                    <text x="37.5" y="25" text-anchor="middle" fill="white" font-size="9" font-weight="bold">2</text>
                                    <text x="52.5" y="25" text-anchor="middle" fill="white" font-size="9" font-weight="bold">1</text>
                                    <text x="67.5" y="25" text-anchor="middle" fill="white" font-size="9" font-weight="bold">2</text>
                                    <text x="22.5" y="40" text-anchor="middle" fill="white" font-size="9" font-weight="bold">1</text>
                                    <text x="37.5" y="40" text-anchor="middle" fill="white" font-size="9" font-weight="bold">1</text>
                                    <text x="52.5" y="40" text-anchor="middle" fill="white" font-size="9" font-weight="bold">2</text>
                                    <text x="67.5" y="40" text-anchor="middle" fill="white" font-size="9" font-weight="bold">3</text>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-icon">üìÅ</div>
            <h3>Upload Your Knitting Pattern</h3>
            <p>Drop your knitting pattern image here or click to browse</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
            <input type="file" id="fileInput" accept="image/*">
            <p style="margin-top: 15px; color: #666; font-size: 14px;">
                <strong>Supported formats:</strong> JPG, PNG, GIF<br>
                <strong>Best results with:</strong> Clear, high-contrast knitting charts
            </p>
        </div>

        <div class="canvas-container" style="position: relative;">
            <canvas id="canvas"></canvas>
        </div>

        <div class="controls-section" style="display: none;" id="controlsSection">
            <h3>üéõÔ∏è Fine-tune Your Pattern</h3>
            <p>Adjust these settings if the automatic detection needs tweaking:</p>
        </div>

        <div class="controls">
            <button class="auto-detect-btn" id="autoDetectBtn" onclick="autoDetectGrid()" disabled>üîç Auto Detect Grid</button>
            <div class="control-group" title="Adjust the size of each stitch grid square">
                <label for="gridSize">Grid Size:</label>
                <input type="range" id="gridSizeSlider" min="5" max="100" value="20">
                <span class="slider-value" id="gridSizeValue">20</span>
                <small>Size of each stitch square</small>
            </div>
            <div class="control-group" title="Move the grid left or right to align with your pattern">
                <label for="offsetX">X Offset:</label>
                <input type="range" id="offsetXSlider" min="-50" max="50" value="0">
                <span class="slider-value" id="offsetXValue">0</span>
                <small>Shift grid horizontally</small>
            </div>
            <div class="control-group" title="Move the grid up or down to align with your pattern">
                <label for="offsetY">Y Offset:</label>
                <input type="range" id="offsetYSlider" min="-50" max="50" value="0">
                <span class="slider-value" id="offsetYValue">0</span>
                <small>Shift grid vertically</small>
            </div>
            <div class="control-group" title="How similar colors should be grouped together">
                <label for="tolerance">Color Grouping:</label>
                <input type="range" id="toleranceSlider" min="0" max="100" value="60">
                <span class="slider-value" id="toleranceValue">60</span>
                <small>Group similar colors together</small>
            </div>
            <div class="control-group" title="Maximum number of different colors to detect in your pattern">
                <label for="maxColors">Max Colors:</label>
                <input type="range" id="maxColorsSlider" min="2" max="20" value="6">
                <span class="slider-value" id="maxColorsValue">6</span>
                <small>Limit color detection</small>
            </div>
            <div class="control-group" title="Show both cell numbers and stitch counts">
                <label for="showCellNumbers">Show Cell Numbers:</label>
                <input type="checkbox" id="showCellNumbers">
                <small>Display cell numbers + stitch counts</small>
            </div>
            <div class="control-group" title="Show the grid lines overlay">
                <label for="showGrid">Show Grid Overlay:</label>
                <input type="checkbox" id="showGrid" checked>
                <small>Display grid lines</small>
            </div>
            <div class="control-group" title="Show color overlay to highlight different yarn colors">
                <label for="showColorOverlay">Show Color Overlay:</label>
                <input type="checkbox" id="showColorOverlay" checked>
                <small>Highlight different colors</small>
            </div>
            <div class="control-group" title="Control transparency of the color overlay">
                <label for="overlayOpacity">Overlay Opacity:</label>
                <input type="range" id="overlayOpacitySlider" min="10" max="100" value="40">
                <span class="slider-value" id="overlayOpacityValue">40%</span>
                <small>Color overlay transparency</small>
            </div>
            <button class="grid-color-btn" id="gridColorBtn" onclick="randomizeGridColor()" disabled>üé® Change Grid Color</button>
            <button class="download-btn" id="downloadBtn" onclick="downloadImage()" disabled>üíæ Download Image</button>
        </div>

        <div class="results-explanation" id="resultsExplanation" style="display: none;">
            <h3>üéØ Your Pattern is Ready!</h3>
            <div class="explanation-grid">
                <div class="explanation-item">
                    <div class="explanation-icon">üìä</div>
                    <div>
                        <strong>Pattern Information</strong>
                        <p>Shows rows, columns, total stitches, and colors used in your pattern</p>
                    </div>
                </div>
                <div class="explanation-item">
                    <div class="explanation-icon">üé®</div>
                    <div>
                        <strong>Pattern Legend</strong>
                        <p>Each color gets a letter (A, B, C...) to make following the pattern easy</p>
                    </div>
                </div>
                <div class="explanation-item">
                    <div class="explanation-icon">üî¢</div>
                    <div>
                        <strong>Row Instructions</strong>
                        <p>Follow row by row - "A3, B2" means 3 stitches of color A, then 2 stitches of color B</p>
                    </div>
                </div>
                <div class="explanation-item">
                    <div class="explanation-icon">üíæ</div>
                    <div>
                        <strong>Download Your Chart</strong>
                        <p>Save the numbered chart as an image to reference while knitting</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="info" id="info" style="display: none;"></div>

        <div class="legend" id="legend" style="display: none;">
            <h3>Pattern Legend</h3>
            <div id="legendContent"></div>
        </div>

        <div style="text-align: center; margin-top: 30px; padding: 20px; border-top: 1px solid #ddd; color: #666; font-size: 14px;">
            Contact: <a href="mailto:contact@olivierroy.dev" style="color: #007bff; text-decoration: none;">contact@olivierroy.dev</a>
        </div>
    </div>

    <script>
        let originalImage = null;
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let fileInput = document.getElementById('fileInput');
        let uploadSection = document.getElementById('uploadSection');
        let gridColorBtn = document.getElementById('gridColorBtn');
        let currentGridColor = 'rgba(255, 255, 255, 0.5)';
        let colorReplacementSection = document.getElementById('colorReplacement');
        let colorReplacementContent = document.getElementById('colorReplacementContent');
        let customColorOverrides = {};

        // Drag and drop functionality
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Add event listeners for checkbox changes
        document.getElementById('showCellNumbers').addEventListener('change', () => {
            if (originalImage) {
                processImage();
            }
        });
        document.getElementById('showGrid').addEventListener('change', () => {
            if (originalImage) {
                processImage();
            }
        });
        document.getElementById('showColorOverlay').addEventListener('change', () => {
            if (originalImage) {
                processImage();
            }
        });

        // Slider event listeners
        function setupSlider(sliderId, valueId) {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(valueId);

            slider.addEventListener('input', () => {
                const value = slider.value;
                // Special formatting for opacity (add %)
                if (sliderId === 'overlayOpacitySlider') {
                    valueDisplay.textContent = value + '%';
                } else {
                    valueDisplay.textContent = value;
                }
                if (originalImage) {
                    if (sliderId === 'gridSizeSlider') {
                        processImage();
                    } else {
                        processImage();
                    }
                }
            });

        }

        // Setup sliders
        setupSlider('gridSizeSlider', 'gridSizeValue');
        setupSlider('offsetXSlider', 'offsetXValue');
        setupSlider('offsetYSlider', 'offsetYValue');
        setupSlider('toleranceSlider', 'toleranceValue');
        setupSlider('maxColorsSlider', 'maxColorsValue');
        setupSlider('overlayOpacitySlider', 'overlayOpacityValue');

        if (colorReplacementContent) {
            colorReplacementContent.addEventListener('change', (event) => {
                const target = event.target;
                if (target.classList.contains('color-override-input')) {
                    const symbol = target.getAttribute('data-symbol');
                    if (symbol) {
                        applyColorOverride(symbol, target.value);
                    }
                }
            });

            colorReplacementContent.addEventListener('click', (event) => {
                const target = event.target;
                if (target.classList.contains('reset-color-btn')) {
                    const symbol = target.getAttribute('data-symbol');
                    if (symbol) {
                        resetColorOverride(symbol);
                    }
                }
            });
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file.');
                return;
            }

            customColorOverrides = {};
            if (colorReplacementSection) {
                colorReplacementSection.style.display = 'none';
                colorReplacementContent.innerHTML = '';
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    displayOriginalImage();
                    document.getElementById('autoDetectBtn').disabled = false;
                    document.getElementById('gridColorBtn').disabled = false;
                    document.getElementById('downloadBtn').disabled = false;

                    // Show controls section
                    document.getElementById('controlsSection').style.display = 'block';

                    // Auto-detect grid and process pattern
                    setTimeout(() => {
                        autoDetectGrid();
                    }, 100);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayOriginalImage() {
            const maxWidth = 1800;
            const scale = Math.min(1, maxWidth / originalImage.width);

            canvas.width = originalImage.width * scale;
            canvas.height = originalImage.height * scale;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

            document.getElementById('info').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
        }

        function autoDetectGrid() {
            if (!originalImage) return;

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Detect grid lines by looking for consistent horizontal and vertical patterns
            const gridSize = detectGridSize(data, canvas.width, canvas.height);

            if (gridSize > 0) {
                document.getElementById('gridSizeSlider').value = gridSize;
                document.getElementById('gridSizeValue').textContent = gridSize;
                // Auto-process pattern after detection
                processImage();
            } else {
                // Use default grid size if detection fails
                processImage();
            }
        }

        function detectGridSize(data, width, height) {
            // Sample horizontal lines to detect grid pattern
            const sampleY = Math.floor(height * 0.1); // Sample from top 10%
            let transitions = [];

            for (let x = 1; x < width - 1; x++) {
                const currentIndex = (sampleY * width + x) * 4;
                const prevIndex = (sampleY * width + (x - 1)) * 4;

                const currentBrightness = (data[currentIndex] + data[currentIndex + 1] + data[currentIndex + 2]) / 3;
                const prevBrightness = (data[prevIndex] + data[prevIndex + 1] + data[prevIndex + 2]) / 3;

                if (Math.abs(currentBrightness - prevBrightness) > 30) {
                    transitions.push(x);
                }
            }

            if (transitions.length < 3) return 0;

            // Calculate most common distance between transitions
            const distances = [];
            for (let i = 1; i < transitions.length; i++) {
                distances.push(transitions[i] - transitions[i - 1]);
            }

            // Find the most frequent distance (grid size)
            const distanceMap = {};
            distances.forEach(d => {
                const rounded = Math.round(d);
                distanceMap[rounded] = (distanceMap[rounded] || 0) + 1;
            });

            let maxCount = 0;
            let detectedSize = 0;

            for (const [size, count] of Object.entries(distanceMap)) {
                if (count > maxCount && parseInt(size) > 8 && parseInt(size) < 50) {
                    maxCount = count;
                    detectedSize = parseInt(size);
                }
            }

            return detectedSize;
        }

        function processImage() {
            if (!originalImage) return;

            const gridSize = parseInt(document.getElementById('gridSizeSlider').value);
            const offsetX = parseInt(document.getElementById('offsetXSlider').value);
            const offsetY = parseInt(document.getElementById('offsetYSlider').value);
            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const maxColors = parseInt(document.getElementById('maxColorsSlider').value);
            const showCellNumbers = document.getElementById('showCellNumbers').checked;
            const showGrid = document.getElementById('showGrid').checked;
            const showColorOverlay = document.getElementById('showColorOverlay').checked;
            const overlayOpacity = parseInt(document.getElementById('overlayOpacitySlider').value) / 100;

            // Clear canvas and redraw image
            displayOriginalImage();

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Calculate grid dimensions accounting for offsets
            const cols = Math.floor((canvas.width - offsetX) / gridSize);
            const rows = Math.floor((canvas.height - offsetY) / gridSize);

            let patternData = [];
            let allCellColors = [];
            let cellNumber = 1;

            // Process each row - create individual cells for each grid position
            for (let row = 0; row < rows; row++) {
                let rowData = [];
                let consecutiveCount = 1;
                let currentColor = null;
                let sequenceStart = 0;

                for (let col = 0; col < cols; col++) {
                    // Get the center pixel of the grid cell with offsets
                    const x = Math.floor(offsetX + (col + 0.5) * gridSize);
                    const y = Math.floor(offsetY + (row + 0.5) * gridSize);

                    if (x < canvas.width && y < canvas.height) {
                        const pixelIndex = (y * canvas.width + x) * 4;
                        const r = data[pixelIndex];
                        const g = data[pixelIndex + 1];
                        const b = data[pixelIndex + 2];

                        // Store raw color data for clustering
                        allCellColors.push({
                            r: r,
                            g: g,
                            b: b,
                            x: x,
                            y: y,
                            col: col,
                            row: row,
                            cellNumber: cellNumber
                        });

                        cellNumber++;
                    }
                }

                // Will be populated after color clustering
                patternData.push([]);
            }

            // Perform color clustering to limit colors and ensure all cells have colors
            const colorMap = performColorClustering(allCellColors, maxColors, tolerance);
            applyCustomColorOverrides(colorMap);

            // Rebuild pattern data with clustered colors
            patternData = rebuildPatternData(allCellColors, colorMap, rows, cols);

            // Draw color overlay if enabled
            if (showColorOverlay) {
                drawColorOverlay(patternData, gridSize, overlayOpacity);
            }

            // Draw grid lines and overlays
            if (showGrid) {
                drawGridLines(gridSize, cols, rows, offsetX, offsetY);
            }
            drawOverlay(patternData, gridSize, showCellNumbers);

            // Show info and legend
            showPatternInfo(patternData, colorMap);

            // Show results explanation
            document.getElementById('resultsExplanation').style.display = 'block';
        }

        function randomizeGridColor() {
            // Generate a bright, visible color with good opacity
            const colors = [
                'rgba(255, 0, 0, 0.7)',     // Red
                'rgba(0, 255, 0, 0.7)',     // Green
                'rgba(0, 0, 255, 0.7)',     // Blue
                'rgba(255, 255, 0, 0.7)',   // Yellow
                'rgba(255, 0, 255, 0.7)',   // Magenta
                'rgba(0, 255, 255, 0.7)',   // Cyan
                'rgba(255, 165, 0, 0.7)',   // Orange
                'rgba(128, 0, 128, 0.7)',   // Purple
                'rgba(255, 192, 203, 0.7)', // Pink
                'rgba(0, 128, 0, 0.7)',     // Dark Green
                'rgba(255, 255, 255, 0.8)', // White
                'rgba(0, 0, 0, 0.8)'        // Black
            ];

            // Pick a random color
            currentGridColor = colors[Math.floor(Math.random() * colors.length)];

            // Reprocess the image if it exists (regardless of button state)
            if (originalImage) {
                processImage();
            }
        }

        function drawGridLines(gridSize, cols, rows, offsetX, offsetY) {
            ctx.strokeStyle = currentGridColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);

            // Draw vertical lines
            for (let col = 0; col <= cols; col++) {
                const x = offsetX + col * gridSize;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + rows * gridSize);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let row = 0; row <= rows; row++) {
                const y = offsetY + row * gridSize;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + cols * gridSize, y);
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        function drawColorOverlay(patternData, gridSize, opacity = 0.4) {
            ctx.globalAlpha = opacity;

            patternData.forEach((row, rowIndex) => {
                row.forEach((cell, cellIndex) => {
                    const cellX = cell.x - gridSize / 2;
                    const cellY = cell.y - gridSize / 2;

                    // Fill cell with detected color
                    ctx.fillStyle = cell.color.color;
                    ctx.fillRect(cellX, cellY, gridSize, gridSize);
                });
            });

            ctx.globalAlpha = 1.0;
        }

        function performColorClustering(cellColors, maxColors, toleranceValue) {
            if (cellColors.length === 0) return new Map();

            const clusterCount = Math.max(1, Math.min(maxColors, cellColors.length));
            const clusters = [];
            for (let i = 0; i < clusterCount; i++) {
                const seedIndex = Math.floor((i * cellColors.length) / clusterCount);
                const seed = cellColors[seedIndex];
                clusters.push({
                    r: seed.r,
                    g: seed.g,
                    b: seed.b,
                    count: 0,
                    sumR: 0,
                    sumG: 0,
                    sumB: 0
                });
            }

            const iterations = 5;
            for (let iteration = 0; iteration < iterations; iteration++) {
                assignCellsToClusters(cellColors, clusters);
                clusters.forEach((cluster, index) => {
                    if (cluster.count > 0) {
                        cluster.r = Math.round(cluster.sumR / cluster.count);
                        cluster.g = Math.round(cluster.sumG / cluster.count);
                        cluster.b = Math.round(cluster.sumB / cluster.count);
                    } else {
                        const fallbackCell = cellColors[(index + iteration * 7) % cellColors.length];
                        cluster.r = fallbackCell.r;
                        cluster.g = fallbackCell.g;
                        cluster.b = fallbackCell.b;
                    }
                });
            }

            assignCellsToClusters(cellColors, clusters);

            const palette = clusters.map((cluster, index) => {
                if (cluster.count > 0) {
                    cluster.r = Math.round(cluster.sumR / cluster.count);
                    cluster.g = Math.round(cluster.sumG / cluster.count);
                    cluster.b = Math.round(cluster.sumB / cluster.count);
                }
                return {
                    index: index,
                    r: cluster.r,
                    g: cluster.g,
                    b: cluster.b,
                    count: cluster.count
                };
            });

            const groupingResult = groupPaletteColors(palette, toleranceValue, maxColors);
            const { paletteGroupIndexes, colorMap, uniqueColors } = groupingResult;

            cellColors.forEach((cell) => {
                const mappedIndex = paletteGroupIndexes[cell.clusterIndex];
                if (mappedIndex !== undefined) {
                    cell.clusterIndex = mappedIndex;
                }
            });

            colorMap.uniqueColors = uniqueColors;
            return colorMap;
        }

        function assignCellsToClusters(cellColors, clusters) {
            clusters.forEach(cluster => {
                cluster.count = 0;
                cluster.sumR = 0;
                cluster.sumG = 0;
                cluster.sumB = 0;
            });

            cellColors.forEach(cell => {
                let minDistance = Infinity;
                let bestCluster = 0;

                clusters.forEach((cluster, index) => {
                    const distance = Math.sqrt(
                        Math.pow(cell.r - cluster.r, 2) +
                        Math.pow(cell.g - cluster.g, 2) +
                        Math.pow(cell.b - cluster.b, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestCluster = index;
                    }
                });

                cell.clusterIndex = bestCluster;
                const target = clusters[bestCluster];
                target.count++;
                target.sumR += cell.r;
                target.sumG += cell.g;
                target.sumB += cell.b;
            });
        }

        function groupPaletteColors(palette, toleranceValue, maxColors) {
            const toleranceDistance = calculateToleranceDistance(toleranceValue, maxColors);
            const colorGroups = [];

            const orderedPalette = palette.slice().sort((a, b) => b.count - a.count);
            orderedPalette.forEach((entry) => {
                const colorVector = { r: entry.r, g: entry.g, b: entry.b };
                let matchingGroup = null;

                for (const group of colorGroups) {
                    if (getColorDistance(colorVector, group.referenceColor) <= toleranceDistance) {
                        matchingGroup = group;
                        break;
                    }
                }

                if (!matchingGroup) {
                    matchingGroup = {
                        referenceColor: { ...colorVector },
                        totalR: 0,
                        totalG: 0,
                        totalB: 0,
                        totalCount: 0,
                        paletteIndexes: []
                    };
                    colorGroups.push(matchingGroup);
                }

                matchingGroup.totalR += entry.r * entry.count;
                matchingGroup.totalG += entry.g * entry.count;
                matchingGroup.totalB += entry.b * entry.count;
                matchingGroup.totalCount += entry.count;
                matchingGroup.paletteIndexes.push(entry.index);
            });

            const colorMap = new Map();
            const uniqueColors = [];
            const paletteGroupIndexes = [];

            colorGroups.forEach((group, groupIndex) => {
                if (group.totalCount === 0) {
                    return;
                }

                const averaged = {
                    r: Math.round(group.totalR / group.totalCount),
                    g: Math.round(group.totalG / group.totalCount),
                    b: Math.round(group.totalB / group.totalCount)
                };
                const color = `rgb(${averaged.r},${averaged.g},${averaged.b})`;
                const colorInfo = {
                    color: color,
                    originalColor: color,
                    symbol: String.fromCharCode(65 + groupIndex),
                    index: groupIndex
                };

                colorMap.set(groupIndex, colorInfo);
                uniqueColors.push(colorInfo);

                group.paletteIndexes.forEach((paletteIndex) => {
                    paletteGroupIndexes[paletteIndex] = groupIndex;
                });
            });

            return { colorMap, uniqueColors, paletteGroupIndexes };
        }

        function calculateToleranceDistance(value, maxColors) {
            const clamped = Math.max(0, Math.min(100, value || 0));
            const minDistance = 5;
            const maxDistance = 80;
            const normalizedTolerance = Math.pow(clamped / 100, 1.2);
            const baseDistance = minDistance + normalizedTolerance * (maxDistance - minDistance);

            const sliderMax = parseInt(document.getElementById('maxColorsSlider')?.max || '20', 10);
            const effectiveMax = Math.max(2, Math.min(sliderMax, maxColors || sliderMax));
            const maxScale = 1 - ((effectiveMax - 2) / (sliderMax - 2)) * 0.6;
            const adjustedScale = Math.max(0.35, maxScale);

            return minDistance + (baseDistance - minDistance) * adjustedScale;
        }

        function getColorDistance(colorA, colorB) {
            const dr = colorA.r - colorB.r;
            const dg = colorA.g - colorB.g;
            const db = colorA.b - colorB.b;
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }

        function getUniqueColors(colorMap) {
            if (!colorMap) return [];
            if (Array.isArray(colorMap.uniqueColors)) {
                return colorMap.uniqueColors;
            }

            const uniqueBySymbol = new Map();
            colorMap.forEach((colorInfo) => {
                if (colorInfo && !uniqueBySymbol.has(colorInfo.symbol)) {
                    uniqueBySymbol.set(colorInfo.symbol, colorInfo);
                }
            });

            const uniqueList = Array.from(uniqueBySymbol.values());
            colorMap.uniqueColors = uniqueList;
            return uniqueList;
        }

        function applyCustomColorOverrides(colorMap) {
            if (!colorMap) return;
            const uniqueColors = getUniqueColors(colorMap);
            const symbolsInUse = new Set();
            uniqueColors.forEach((colorInfo) => {
                symbolsInUse.add(colorInfo.symbol);
                if (!colorInfo.originalColor) {
                    colorInfo.originalColor = colorInfo.color;
                }
                const override = customColorOverrides[colorInfo.symbol];
                colorInfo.color = override || colorInfo.originalColor;
            });

            Object.keys(customColorOverrides).forEach((symbol) => {
                if (!symbolsInUse.has(symbol)) {
                    delete customColorOverrides[symbol];
                }
            });
        }

        function renderColorReplacementControls(colorMap) {
            if (!colorReplacementSection || !colorReplacementContent) return;

            if (!colorMap) {
                colorReplacementSection.style.display = 'none';
                colorReplacementContent.innerHTML = '';
                return;
            }

            const uniqueColors = getUniqueColors(colorMap);
            if (uniqueColors.length === 0) {
                colorReplacementSection.style.display = 'none';
                colorReplacementContent.innerHTML = '';
                return;
            }

            let replacementHTML = '';
            uniqueColors.forEach((colorInfo) => {
                const currentColorHex = colorToHex(customColorOverrides[colorInfo.symbol] || colorInfo.color);
                replacementHTML += `
                    <div class="color-replacement-item">
                        <div>
                            <strong>Color ${colorInfo.symbol}</strong>
                        </div>
                        <div class="color-preview-group">
                            <div>
                                <span class="color-sample" style="background-color: ${colorInfo.originalColor};"></span>
                                <small>Original</small>
                            </div>
                            <div>
                                <span class="color-sample" style="background-color: ${colorInfo.color};"></span>
                                <small>Current</small>
                            </div>
                        </div>
                        <input type="color" class="color-override-input" data-symbol="${colorInfo.symbol}" value="${currentColorHex}">
                        <button type="button" class="reset-color-btn" data-symbol="${colorInfo.symbol}" ${customColorOverrides[colorInfo.symbol] ? '' : 'disabled'}>Reset</button>
                    </div>
                `;
            });

            colorReplacementContent.innerHTML = replacementHTML;
            colorReplacementSection.style.display = 'block';
        }

        function colorToHex(colorValue) {
            if (!colorValue) return '#000000';
            if (colorValue.startsWith('#')) {
                return normalizeHex(colorValue);
            }

            const rgbMatch = colorValue.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
            if (!rgbMatch) {
                return '#000000';
            }

            const r = parseInt(rgbMatch[1], 10);
            const g = parseInt(rgbMatch[2], 10);
            const b = parseInt(rgbMatch[3], 10);
            return '#' + [r, g, b].map((value) => value.toString(16).padStart(2, '0')).join('');
        }

        function normalizeHex(hexValue) {
            if (!hexValue) return '#000000';
            let hex = hexValue.trim();
            if (!hex.startsWith('#')) {
                hex = `#${hex}`;
            }
            if (hex.length === 4) {
                const [, r, g, b] = hex;
                hex = `#${r}${r}${g}${g}${b}${b}`;
            }
            if (hex.length !== 7) {
                return '#000000';
            }
            return hex.toLowerCase();
        }

        function applyColorOverride(symbol, color) {
            if (!symbol || !color) return;
            customColorOverrides[symbol] = color;
            if (originalImage) {
                processImage();
            }
        }

        function resetColorOverride(symbol) {
            if (!symbol) return;
            delete customColorOverrides[symbol];
            if (originalImage) {
                processImage();
            }
        }

        function rebuildPatternData(cellColors, colorMap, rows, cols) {
            const patternData = [];

            for (let row = 0; row < rows; row++) {
                const rowData = [];
                let currentColor = null;
                let consecutiveCount = 0;

                for (let col = 0; col < cols; col++) {
                    const cellIndex = row * cols + col;
                    if (cellIndex < cellColors.length) {
                        const cell = cellColors[cellIndex];
                        const colorInfo = colorMap.get(cell.clusterIndex);

                        // Check if this is the same color as the previous cell
                        if (currentColor === null || currentColor !== cell.clusterIndex) {
                            currentColor = cell.clusterIndex;
                            consecutiveCount = 1;
                        } else {
                            consecutiveCount++;
                        }

                        rowData.push({
                            color: colorInfo,
                            x: cell.x,
                            y: cell.y,
                            consecutivePosition: consecutiveCount,
                            cellNumber: cell.cellNumber,
                            col: cell.col,
                            row: cell.row
                        });
                    }
                }
                patternData.push(rowData);
            }

            return patternData;
        }

        function drawOverlay(patternData, gridSize, showCellNumbers) {
            const fontSize = Math.min(gridSize * 0.4, 12);
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'black';

            patternData.forEach((row, rowIndex) => {
                row.forEach((cell, cellIndex) => {
                    if (showCellNumbers) {
                        // Show cell number in top part and consecutive position in bottom part
                        const cellText = cell.cellNumber.toString();
                        const textY = cell.y - gridSize * 0.15;
                        ctx.strokeText(cellText, cell.x, textY);
                        ctx.fillText(cellText, cell.x, textY);

                        // Show consecutive position (1, 2, 3...) in bottom part
                        const consecutiveText = cell.consecutivePosition.toString();
                        const countY = cell.y + gridSize * 0.15;
                        ctx.font = `bold ${fontSize * 0.8}px Arial`;
                        ctx.strokeText(consecutiveText, cell.x, countY);
                        ctx.fillText(consecutiveText, cell.x, countY);
                        ctx.font = `bold ${fontSize}px Arial`; // Reset font size
                    } else {
                        // Show only consecutive position (1, 2, 3...)
                        const text = cell.consecutivePosition.toString();
                        ctx.strokeText(text, cell.x, cell.y);
                        ctx.fillText(text, cell.x, cell.y);
                    }
                });
            });
        }

        function showPatternInfo(patternData, colorMap) {
            const info = document.getElementById('info');
            const legend = document.getElementById('legend');
            const legendContent = document.getElementById('legendContent');

            let totalStitches = 0;
            let patternText = '';
            const uniqueColors = getUniqueColors(colorMap);

            patternData.forEach((row, rowIndex) => {
                patternText += `Row ${rowIndex + 1}: `;
                let currentColor = null;
                let consecutiveCount = 0;
                let rowStitches = 0;

                row.forEach((cell, cellIndex) => {
                    rowStitches++;

                    if (currentColor === null || currentColor !== cell.color.symbol) {
                        // New color sequence
                        if (currentColor !== null) {
                            patternText += `${currentColor}${consecutiveCount > 1 ? consecutiveCount : ''}, `;
                        }
                        currentColor = cell.color.symbol;
                        consecutiveCount = 1;
                    } else {
                        consecutiveCount++;
                    }
                });

                // Add the last color sequence for the row
                if (currentColor !== null) {
                    patternText += `${currentColor}${consecutiveCount > 1 ? consecutiveCount : ''}`;
                }

                totalStitches += rowStitches;
                patternText += '\n';
            });

            info.innerHTML = `
                <strong>Pattern Information:</strong><br>
                Rows: ${patternData.length}<br>
                Columns: ${patternData[0].length}<br>
                Total Stitches: ${totalStitches}<br>
                Colors Used: ${uniqueColors.length}<br><br>
                <strong>Pattern:</strong><br>
                <pre>${patternText}</pre>
            `;

            // Create legend
            let legendHTML = '';
            uniqueColors.forEach((colorInfo) => {
                legendHTML += `
                    <div style="margin-bottom: 5px;">
                        <span class="color-sample" style="background-color: ${colorInfo.color};"></span>
                        <strong>${colorInfo.symbol}</strong> - ${colorInfo.color}
                    </div>
                `;
            });

            legendContent.innerHTML = legendHTML;
            renderColorReplacementControls(colorMap);

            info.style.display = 'block';
            legend.style.display = 'block';
        }

        function downloadImage() {
            if (!originalImage) return;

            // Create a temporary link element
            const link = document.createElement('a');

            // Convert canvas to blob and download
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = 'knitting-pattern-numbered.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
    </script>

    <script defer src="https://umami.olivierroy.dev/script.js" data-website-id="e3b7ae1e-458e-495b-8875-0e526f11cb95"></script>

    <script>
    window.op=window.op||function(){var n=[];return new Proxy(function(){arguments.length&&n.push([].slice.call(arguments))},{get:function(t,r){return"q"===r?n:function(){n.push([r].concat([].slice.call(arguments)))}} ,has:function(t,r){return"q"===r}}) }();
    window.op('init', {
        clientId: 'bdd2f226-b71b-4d36-bc30-655798134e7c',
        trackScreenViews: true,
        trackOutgoingLinks: true,
        trackAttributes: true,
    });
    </script>
    <script src="https://openpanel.dev/op1.js" defer async></script>

    <script src="https://swetrix.org/swetrix.js" defer></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        swetrix.init('uALvJbDKjZKk', {
        apiURL: 'https://swetrixapi.olivierroy.dev/log',
        })
        swetrix.trackViews()
    })
    </script>

    <noscript>
    <img
        src="https://swetrixapi.olivierroy.dev/log/noscript?pid=uALvJbDKjZKk"
        alt=""
        referrerpolicy="no-referrer-when-downgrade"
    />
    </noscript>

</body>
</html>
